#include "instruction.h"
#include "prog.h"
#include "platform.h"
#include "util.h"
#include <fstream>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <cstring>
#include <list>
#include <math.h>
#include <algorithm>
#include <iterator>
#include <iomanip>

using namespace std;

Program gen_test_prog(int bank, int r1, int r2, int iters, int read_cols, int placement)
{
  Program program;

  program.add_inst(SMC_LI(8, CASR)); // Load 8 into CASR since each READ reads 8 columns
  program.add_inst(SMC_LI(1, RASR)); // Load 1 into RASR

  program.add_inst(SMC_LI(bank, BAR));
  program.add_inst(SMC_LI(r1, RARBASE));

  program.add_inst(SMC_LI(iters, ITER_REG));
  program.add_inst(SMC_LI(0, CTR_REG));
  
  program.add_inst(SMC_PRE(BAR,0,1),SMC_NOP(),SMC_NOP(),SMC_NOP());
  program.add_inst(SMC_SLEEP(5));  

  program.add_inst(SMC_LI(r1, RAR1));
  program.add_inst(SMC_LI(r2, RAR2));

  program.add_label("WRITE_BEGIN");
  //program.add_below(genWriteRange(RARBASE, 4, BAR, true));
  switch(placement)
  {
    // Invert 0-1 start pattern before here when we set the
    // WIDEREG
    case 1000:
      program.add_below(genWriteRange1000(RARBASE, 4, BAR));
      break;
    case 1001:
      program.add_below(genWriteRange1001(RARBASE, 4, BAR));
      break;
    case 1010:
      program.add_below(genWriteRange1010(RARBASE, 4, BAR));
      break;
    case 1011:
      program.add_below(genWriteRange1011(RARBASE, 4, BAR));
      break;
    case 1100:
      program.add_below(genWriteRange1100(RARBASE, 4, BAR));
      break;
    case 1101:
      program.add_below(genWriteRange1101(RARBASE, 4, BAR));
      break;
    case 1110:
      program.add_below(genWriteRange1110(RARBASE, 4, BAR));
      break;
    case 1111:
      program.add_below(genWriteRange1111(RARBASE, 4, BAR));
      break;
    default:
      printf("Unexpected placement encoding\n");
      exit(0);
  }

  program.add_below(genActPreActSequence(1, 1, RAR1, RAR2, BAR));
  program.add_inst(SMC_SLEEP(4));
  program.add_inst(SMC_PRE(BAR, 0, 1), SMC_NOP(), SMC_NOP(), SMC_NOP());
  program.add_inst(SMC_SLEEP(4));
  program.add_below(genReadRange(RARBASE, 1, BAR, read_cols));

  program.add_inst(SMC_ADDI(CTR_REG, 1, CTR_REG));
  program.add_branch(program.BR_TYPE::BL, CTR_REG, ITER_REG, "WRITE_BEGIN");
  program.add_inst(SMC_END());

  return program;
}

int main(int argc, char *argv[])
{
  bool DUMP_RAW = false;

  SoftMCPlatform platform;
  int err;
  
  // buffer allocated for reading data from the board
  uint8_t buf[4*READ_CL*64];

  // Initialize the platform, opens file descriptors for the board PCI-E interface.
  if((err = platform.init()) != SOFTMC_SUCCESS){
      cerr << "Could not initialize SoftMC Platform: " << err << endl;
  }
  // reset the board to hopefully restore the board's state
  platform.reset_fpga();
  platform.set_aref(true);

  int bank = 1;

  int row_stride = atoi(argv[3]);

  string placement = argv[2];
  bool invert = false;

  int iters = atoi(argv[4]);

  ofstream ent_file;
  string fn = string(argv[1]) + "/" + to_string(bank) + "_" + to_string(iters) + "_" + to_string(READ_CL) + "_" + to_string(NO_ROWS) + "_" + placement + ".txt";
  cout << "Saving to file " << fn << endl;
  ent_file.open(fn);

  char new_placement[10];
  if (placement[0] == '0')
  {
    for (std::string::size_type i = 0 ; i < placement.size() ; i++)
      if(placement[i] == '0')
        new_placement[i] = '1';
      else if(placement[i] == '1')
        new_placement[i] = '0';
      else
        new_placement[i] = placement[i];
    placement = string(new_placement);
    invert = true;
  }

  Program program;
  program.add_inst(SMC_LI(invert ? 0x0 : 0xffffffff, PATTERN_REG));
  program.add_inst(SMC_LI(invert ? 0xffffffff : 0x0, INV_PATTERN_REG));
  for(int i = 0 ; i < 16 ; i++)
    program.add_inst(SMC_LDWD(PATTERN_REG,i));
  program.add_inst(SMC_END());
  platform.execute(program);

  unsigned char *byte_buf[READ_CL*64];
  for(int i = 0 ; i < READ_CL*64 ; i++)
    byte_buf[i] = new unsigned char[iters];

  // Frequency of 1s and 0s generated by each bitline
  int alphabet[READ_CL*64*8][2];

  ent_file << NO_ROWS/row_stride << " " << READ_CL << endl;

  for(int r1 = 0 ; r1 < NO_ROWS ; r1+=row_stride)
  {
    ent_file << r1 << " ";
    Program prog = gen_test_prog(bank, r1, r1+3, iters, READ_CL, std::stoi(placement));
    platform.execute(prog);

    for(int i = 0 ; i < iters ; i++)
    {  
      platform.receiveData((char*)buf, READ_CL*64); // read one segment each iteration
      for(int j = 0 ; j < READ_CL*64 ; j++)
        byte_buf[j][i] = buf[j];
    }

    for(int i = 0 ; i < READ_CL*64*8 ; i++)
      for(int j = 0 ; j < 2 ; j++)
        alphabet[i][j] = 0;

    for(int j = 0 ; j < READ_CL*64*8 ; j++)
    {
      for(int i = 0 ; i < iters ; i++)
        alphabet[j][(byte_buf[j/8][i]>>(j%8))&0x1] += 1; 

      float approxent = 0;
      for(int i = 0 ; i < 2 ; i++)
      {
        int freq = alphabet[j][i];
        float p = ((float) freq) / ((float) iters);
        approxent -= freq == 0 ? 0 : p * log2(p); 
      }      

      ent_file << approxent << " ";

      /*
      if(approxent > 0.995)
      {
        unsigned char bits[iters/8]{0};
        for(int i = 0 ; i < iters ; i++)
          bits[i/8] |= ((byte_buf[j/8][i] >> (j%8)) & 0x1) << (7-(i%8));
        ofstream dump_file;
        string fn = string(argv[2]) + "/" + to_string(r1) + "_" + to_string(j) + ".bin";
        dump_file.open(fn, ofstream::binary);
        dump_file.write((char*)(bits), iters/8);
        dump_file.close();
      }
      */
    }
  
    ent_file << endl;

    printf("\rrow %d", r1);
    fflush(stdout);
  }
  for(int i = 0 ; i < READ_CL*64 ; i++)
    delete byte_buf[i];
  ent_file.close();
}
